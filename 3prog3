#include <iostream>
#include <string>

class Node {
public:
    std::string data;
    Node* next;

    Node(const std::string& value) : data(value), next(nullptr) {}
};

class Queue {
private:
    Node* head;
    Node* tail;

public:
    Queue() : head(nullptr), tail(nullptr) {}

    ~Queue() {
        while (head) {
            Node* temp = head;
            head = head->next;
            delete temp;
        }
    }

    // Метод добавления элемента в конец очереди
    void enqueue(const std::string& value) {
        Node* newNode = new Node(value);
        if (!head) {
            head = tail = newNode;
        } else {
            tail->next = newNode;
            tail = newNode;
        }
    }

    // Метод извлечения элемента из начала очереди
    std::string dequeue() {
        if (!head) {
            throw std::runtime_error("Queue is empty.");
        }
        std::string value = head->data;
        Node* temp = head;
        head = head->next;
        delete temp;
        if (!head) {
            tail = nullptr;
        }
        return value;
    }

    // Метод поиска элемента
    bool contains(const std::string& value) const {
        Node* current = head;
        while (current) {
            if (current->data == value) {
                return true;
            }
            current = current->next;
        }
        return false;
    }

    // Метод вычисления веса элемента
    int weight(const std::string& value) const {
        Node* current = head;
        int index = 0;
        while (current) {
            if (current->data == value) {
                return index + 1; // Нумерация с 1
            }
            current = current->next;
            index++;
        }
        return -1; // Элемент не найден
    }

    // Перегрузка оператора +
    Queue operator+(const Queue& other) const {
        Queue result;
        Node* current = head;
        while (current) {
            result.enqueue(current->data);
            current = current->next;
        }
        current = other.head;
        while (current) {
            result.enqueue(current->data);
            current = current->next;
        }
        return result;
    }

    // Перегрузка оператора *
    Queue operator*(const Queue& other) const {
        Queue result;
        Node* current1 = head;
        Node* current2 = other.head;
        while (current1 || current2) {
            if (current1) {
                result.enqueue(current1->data);
                current1 = current1->next;
            }
            if (current2) {
                result.enqueue(current2->data);
                current2 = current2->next;
            }
        }
        return result;
    }

    // Унарная перегрузка оператора - (разворот очереди)
    Queue operator-() const {
        Queue result;
        Node* current = head;
        while (current) {
            Node* newNode = new Node(current->data);
            newNode->next = result.head;
            result.head = newNode;
            if (!result.tail) {
                result.tail = newNode;
            }
            current = current->next;
        }
        return result;
    }

    // Метод удаления элемента
    void DolgoZdat(const std::string& value) {
        Node* current = head;
        Node* previous = nullptr;

        while (current) {
            if (current->data == value) {
                if (previous) {
                    previous->next = current->next;
                } else {
                    head = current->next;
                }
                if (current == tail) {
                    tail = previous;
                }
                delete current;
                return; // Элемент найден и удален; выходим
            }
            previous = current;
            current = current->next;
        }
    }

    // Метод для вывода очереди (для проверки)
    void print() const {
        Node* current = head;
        while (current) {
            std::cout << current->data << " ";
            current = current->next;
        }
        std::cout << std::endl;
    }
};

int main() {
    Queue q1;
    q1.enqueue("a1");
    q1.enqueue("a2");
    q1.enqueue("a3");
    std::cout << "Queue 1: ";
    q1.print();

    Queue q2;
    q2.enqueue("b1");
    q2.enqueue("b2");
    std::cout << "Queue 2: ";
    q2.print();

    // Перегрузка +
    Queue q3 = q1 + q2;
    std::cout << "Combined Queue: ";
    q3.print();

    // Перегрузка *
    Queue q4 = q1 * q2;
    std::cout << "Crossed Queue: ";
    q4.print();

    // Перегрузка -
    Queue q5 = -q1;
    std::cout << "Reversed Queue 1: ";
    q5.print();

    // Поиск элемента
    std::cout << "Contains 'a2': " << q1.contains("a2") << std::endl;

    // Вычисление веса элемента
    std::cout << "Weight of 'a2': " << q1.weight("a2") << std::endl;

    // Удаление элемента
    q1.DolgoZdat("a2");
    std::cout << "Queue after deleting 'a2': ";
    q1.print();

    return 0;
}

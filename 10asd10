#include <iostream>
#include <vector>

// Функция для разделения массива на две части
int partition(std::vector<int>& arr, int low, int high) {
    int pivot = arr[high]; // Опорный элемент
    int i = (low - 1); // Индекс меньшего элемента

    for (int j = low; j <= high - 1; j++) {
        // Если текущий элемент меньше или равен опорному
        if (arr[j] <= pivot) {
            i++; // Увеличиваем индекс меньшего элемента
            std::swap(arr[i], arr[j]);
        }
    }
    std::swap(arr[i + 1], arr[high]);
    return (i + 1);
}

// Функция для выполнения быстрой сортировки
void quickSort(std::vector<int>& arr, int low, int high) {
    if (low < high) {
        // pi - индекс разделения, arr[pi] на правильной позиции
        int pi = partition(arr, low, high);

        // Рекурсивно сортируем элементы до и после разделения
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

int main() {
    setlocale(LC_ALL, "RU");
    std::vector<int> arr = { 10, 7, 8, 9, 1, 5 };

    std::cout << "Исходная последовательность: ";
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    quickSort(arr, 0, arr.size() - 1);

    std::cout << "Отсортированная последовательность: ";
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}
//Как работает быстрая сортировка
//Схему алгоритма можно описать таким образом :
//
//Выбрать опорный элемент в массиве — часто встречается вариант с центральным элементом.
//Разделить массив на две части следующим образом : все элементы из левой части, которые больше или равны опорному, перекидываем в правую, аналогично, все элементы из правой, которые меньше или равны опорному кидаем в левую часть.
//В результате предыдущего шага в левой части массива останутся элементы, которые меньше или равны центральному, а в правой — больше либо равны.
//Наглядно это можно показать таким образом :
//| ——————— | ————————— | ———————|
//| mas[i] <= mid | mid = mas[size / 2] | mas[i] >= mid   |
//|——————— - | ————————— | ——————— |
//Рекурсивно повторяем действие для левой и правой части массива.
//Заходы в рекурсию прекратятся в тот момент, когда размер обоих частей будет меньше или равен единице.
